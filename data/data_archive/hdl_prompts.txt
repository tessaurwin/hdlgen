[
	{
		"id": "vector_part_select",
		"instruction": "A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of a 4-byte word.",
		"module_declaration": "
		module top_module( 
			input [31:0] in,
			output [31:0] out 
		);",
		"output": "
		module top_module( 
			input [31:0] in,
			output [31:0] out 
		);
  
			assign out[31:24] = in[7:0];
			assign out[23:16] = in[15:8];
			assign out[15:8]  = in[23:16];
			assign out[7:0]   = in[31:24];

		endmodule"
	},{
		"id": "bitwise_operators",
		"instruction": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.",
		"module_declaration": "
		module top_module( 
			input [2:0] a,
			input [2:0] b,
			output [2:0] out_or_bitwise,
			output out_or_logical,
			output [5:0] out_not
		);",
		"output": "
		module top_module( 
			input [2:0] a,
			input [2:0] b,
			output [2:0] out_or_bitwise,
			output out_or_logical,
			output [5:0] out_not
		);
  
			assign out_or_bitwise = a | b;
			assign out_or_logical = a || b;
			assign out_not[5:3] = ~(b[2:0]);
			assign out_not[2:0] = ~(a[2:0]);

		endmodule"
	},{
		"id": "four_input_gates",
		"instruction": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs:
	- out_and: output of a 4-input AND gate.
    - out_or: output of a 4-input OR gate.
    - out_xor: output of a 4-input XOR gate.",
		"module_declaration": "
		module top_module( 
			input [3:0] in,
			output out_and,
			output out_or,
			output out_xor
		);",
		"output": "
		module top_module( 
			input [3:0] in,
			output out_and,
			output out_or,
			output out_xor
		);

			assign out_and = (in[3] & in[2] & in[1] & in[0]);
			assign out_or  = (in[3] | in[2] | in[1] | in[0]);
			assign out_xor = (in[3] ^ in[2] ^ in[1] ^ in[0]);

		endmodule"
	},{
		"id": "vector_concatenation",
		"instruction": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits.",
		"module_declaration": "
		module top_module (
			input [4:0] a, b, c, d, e, f,
			output [7:0] w, x, y, z 
		);",
		"output": "
		module top_module (
			input [4:0] a, b, c, d, e, f,
			output [7:0] w, x, y, z 
		);

			assign {w,x,y,z} = {a,b,c,d,e,f,2'b11};

		endmodule"
	},{
		"id": "4",
		"instruction": "Implement the circuit described by the Karnaugh map below.
		bc | a=0 | a=1 |
		00 |  0  |  1  |
		01 |  1  |  1  |
		11 |  1  |  1  |
		10 |  1  |  1  |",
		"module_declaration": "
		module top_module(
			input a,
			input b,
			input c,
			output out  
		);",
		"output": "
		module top_module(
			input a,
			input b,
			input c,
			output out  
		);
		
		assign out = a | b | c;
		
		endmodule"
	},{
		"id": "5",
		"instruction": "Implement the circuit described by the Karnaugh map below.
			  | ab=00 | ab=01 | ab=11 | ab=10 |
		cd=00 | out=1 | out=1 | out=0 | out=1 |
		cd=01 | out=1 | out=0 | out=0 | out=1 |
		cd=11 | out=0 | out=1 | out=1 | out=1 |
		cd=10 | out=1 | out=1 | out=0 | out=0 |",
		"module_declaration": "
		module top_module(
			input a,
			input b,
			input c,
			input d,
			output out  
		);",
		"output": "
		module top_module(
			input a,
			input b,
			input c,
			input d,
			output out  
		);
		
		assign out = (~b & ~c) | (~a & ~d) | (~a & b & c) | (a & c & d);
		
		endmodule"
	},{
		"id": "6",
		"instruction": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. ",
		"module_declaration": "
		module top_module (
			input too_cold,
			input too_hot,
			input mode,
			input fan_on,
			output heater,
			output aircon,
			output fan
		);",
		"output": "
		module top_module (
			input too_cold,
			input too_hot,
			input mode,
			input fan_on,
			output heater,
			output aircon,
			output fan
		);
    
			assign heater = mode & too_cold;
			assign aircon = (~mode) & too_hot;
			assign fan = fan_on | (heater | aircon);

		endmodule"
	},{
		"id": "7",
		"instruction": "A 'population count' circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.",
		"module_declaration": "
		module top_module( 
			input [2:0] in,
			output [1:0] out 
		);",
		"output": "
		module top_module( 
			input [2:0] in,
			output [1:0] out 
		);
  
			integer i;
    
			always @(*) begin
				out = 2'b0;
				for(i = 0; i < 3; i ++) begin
					if(in[i])
						out = out + 2'b1;
				end
			end

		endmodule"
	},{
		"id": "8",
		"instruction": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.",
		"module_declaration": "
		module top_module( 
			input a, b, sel,
			output out 
		);",
		"output": "
		module top_module( 
			input a, b, sel,
			output out 
		);
  
			assign out = sel ? b : a;

		endmodule"
	},{
		"id": "9",
		"instruction": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.",
		"module_declaration": "
		module top_module( 
			input [15:0] a, b, c, d, e, f, g, h, i,
			input [3:0] sel,
			output [15:0] out 
		);",
		"output": "
		module top_module( 
			input [15:0] a, b, c, d, e, f, g, h, i,
			input [3:0] sel,
			output [15:0] out 
		);
    
			always@(*)begin
				case(sel)
					4'h0 : out = a;
					4'h1 : out = b;
					4'h2 : out = c;
					4'h3 : out = d;
					4'h4 : out = e;
					4'h5 : out = f;
					4'h6 : out = g;
					4'h7 : out = h;
					4'h8 : out = i;
					default : out = 16'hFFFF;
				endcase
			end

		endmodule"
	},{
		"id": "10",
		"instruction": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.",
		"module_declaration": "
		module top_module( 
			input [1023:0] in,
			input [7:0] sel,
			output [3:0] out 
		);",
		"output": "
		module top_module( 
			input [1023:0] in,
			input [7:0] sel,
			output [3:0] out 
		);
    
			assign out = in[sel*4 +: 4];

		endmodule"
	},{
		"id": "11",
		"instruction": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.",
		"module_declaration": "
		module top_module( 
			input [1023:0] in,
			input [7:0] sel,
			output [3:0] out 
		);",
		"output": "
		module top_module (
			input [1023:0] in,
			input [7:0] sel,
			output [3:0] out
		);

			assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};

		endmodule"
	},{
		"id": "12",
		"instruction": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.",
		"module_declaration": "
		module top_module( 
			input a, b,
			output cout, sum 
		);",
		"output": "
		module top_module( 
			input a, b,
			output cout, sum 
		);
  
			assign sum = a ^ b;
			assign cout = a & b;

		endmodule"
	},{
		"id": "13",
		"instruction": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.",
		"module_declaration": "
		module top_module( 
			input a, b, cin,
			output cout, sum 
		);",
		"output": "
		module top_module( 
			input a, b, cin,
			output cout, sum 
		);
  
			assign sum = a ^ b ^ cin;
			assign cout = a & b | a & cin | b & cin;

		endmodule"
	},{
		"id": "14",
		"instruction": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.",
		"module_declaration": "
		module top_module (
			input [7:0] a,
			input [7:0] b,
			output [7:0] s,
			output overflow
		);",
		"output": "
		module top_module (
			input [7:0] a,
			input [7:0] b,
			output [7:0] s,
			output overflow
		);
     
			assign s = a + b;
			assign overflow = (~(a[7] ^ b[7])) & (s[7] != a[7]);

		endmodule"
	},{
		"id": "15",
		"instruction": "Now that you know how to build a full adder, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see.",
		"module_declaration": "
		module top_module( 
			input [2:0] a, b,
			input cin,
			output [2:0] cout,
			output [2:0] sum 
		);",
		"output": "
		module top_module( 
			input [2:0] a, b,
			input cin,
			output [2:0] cout,
			output [2:0] sum 
		);
			wire [2:0] cout1;
			fadd f1(a[0],b[0],cin,cout1[0],sum[0]);
			fadd f2(a[1],b[1],cout1[0],cout1[1],sum[1]);
			fadd f3(a[2],b[2],cout1[1],cout1[2],sum[2]);
			assign cout = cout1;
		endmodule
	
		module fadd( 
			input a, b, cin,
			output cout, sum 
		);
			assign sum = a^b^cin;
			assign cout = (a&b)|(b&cin)|(a&cin);
		endmodule"
	},{
		"id": "16",
		"instruction": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.",
		"module_declaration": "
		module top_module (
			input a,
			input b,
			input c,
			input d,
			output out_sop,
			output out_pos
		);",
		"output": "
		module top_module (
			input a,
			input b,
			input c,
			input d,
			output out_sop,
			output out_pos
		); 
  
			assign out_sop = (c & d) | (~a & ~b & c);
			assign out_pos = (c) & (~a | b) & (d | ~b);

		endmodule"
	},{
		"id": "17",
		"instruction": "Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.",
		"module_declaration": "
		module top_module (
			input clk,
			input areset,   // active high asynchronous reset
			input [7:0] d,
			output [7:0] q
		);",
		"output": "
		module top_module (
			input clk,
			input areset,
			input [7:0] d,
			output [7:0] q
		);
		
			always@(posedge clk,posedge areset)begin
				if(areset)
					q <= 0;
				else
					q <= d;
			end

		endmodule"
	},{
		"id": "18",
		"instruction": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.",
		"module_declaration": "
		module top_module (
			input clk,
			input reset,      // Synchronous active-high reset
			output [3:0] q
		);",
		"output": "
		module top_module (
			input clk,
			input reset,
			output [3:0] q
		);
  
			always@(posedge clk)begin
				if(reset)
					q <= 0;
				else
					q <= q + 1'b1;
			end

		endmodule"
	},{
		"id": "19",
		"instruction": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.",
		"module_declaration": "
		module top_module (
			input clk,
			input reset,        // Synchronous active-high reset
			output [3:0] q
		);",
		"output": "
		module top_module (
			input clk,
			input reset,       
			output [3:0] q
		);
  
			always@(posedge clk) begin
				if(reset | q==9)
					q <= 0;
				else
					q <= q + 1'b1;
			end

		endmodule"
	},{
		"id": "20",
		"instruction": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second). reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.",
		"module_declaration": "
		module top_module(
			input clk,
			input reset,
			input ena,
			output pm,
			output [7:0] hh,
			output [7:0] mm,
			output [7:0] ss
		);",
		"output": "
		module top_module(
			input clk,
			input reset,
			input ena,
			output pm,
			output [7:0] hh,
			output [7:0] mm,
			output [7:0] ss
		);
    
			reg [2:0] ena_hms;	//determine when will "ss","mm" and "hh" need to be increased
			assign ena_hms = {(ena && (mm == 8'h59) && (ss == 8'h59)), (ena && (ss == 8'h59)), ena};   
    
			count60 count_ss(
				.clk(clk),
				.reset(reset),
				.ena(ena_hms[0]),
				.q(ss)
			);
			count60 count_mm(
				.clk(clk),
				.reset(reset),
				.ena(ena_hms[1]),
				.q(mm)
			);
			
			always @(posedge clk) begin
				if(reset) begin
					hh <= 8'h12;    //hh=12
					pm <= 0;
				end
				else begin
					if(ena_hms[2] && (mm == 8'h59) && (ss == 8'h59)) begin    //if mm=59 and ss=59
						if(hh == 8'h12)  hh <= 8'h1; //hh changes:12AM->1AM or 12PM->1PM  
						else if(hh == 8'h11) begin  //if hh=11, PM->AM or AM->PM
							hh[3:0] <= hh[3:0] + 1'h1; //hh=12
							pm <= ~pm;
						end 
						else begin
							if(hh[3:0] == 4'h9) begin
								hh[3:0] <= 4'h0;
								hh[7:4] <= hh[7:4] + 1'h1;
							end
							else hh[3:0] = hh[3:0] + 1'h1;
						end
					end
					else hh <= hh;
				end
			end
		
		endmodule
		
		module count60(
			input clk,
			input reset,
			input ena,
			output [7:0] q
		);
			always @(posedge clk) begin
				if(reset) q <= 8'h0;
				else begin
					if(ena) begin 
						if(q[3:0] == 4'h9) begin
							if(q[7:4] == 4'h5) q <= 8'h0;
							else begin
								q[7:4] <= q[7:4] + 1'h1;
								q[3:0] <= 4'h0;
							end 
						end
						else q[3:0] <= q[3:0] + 1'h1; 
					end
					else q <= q;
				end
			end
		endmodule"
	},{
		"id": "21",
		"instruction": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second). reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.",
		"module_declaration": "
		module top_module(
			input clk,
			input reset,
			input ena,
			output pm,
			output [7:0] hh,
			output [7:0] mm,
			output [7:0] ss
		);",
		"output": "
		module top_module(
			input clk,
			input reset,
			input ena,
			output pm,
			output [7:0] hh,
			output [7:0] mm,
			output [7:0] ss
		); 
			always@(posedge clk)
				begin
					if(reset) begin hh[3:0]<=4'd2;hh[7:4]<=4'd1; mm<=8'h00; ss<=8'h00; pm<=1'b0; end
					else if(ena)
						begin
							if(ss[3:0] != 4'd9) ss[3:0]<=ss[3:0]+4'd1;
							else
								begin
									ss[3:0]<=4'd0;
									ss[7:4]<=ss[7:4]+4'd1;
									if(ss[7:4]== 4'd5) 
										begin
											ss[7:4]<=4'd0;
											mm[3:0]<=mm[3:0]+4'd1;
											if(mm[3:0] == 4'd9)
												begin
													mm[3:0]<=4'd0;
													mm[7:4]<=mm[7:4]+4'd1;
													if(mm[7:4] == 4'd5)
														begin
															mm[7:4]<=4'd0;
															hh[3:0]<=hh[3:0]+4'd1;
															if(hh[3:0] == 4'd9)
																begin
																	hh[3:0]<=4'd0;
																	hh[7:4]<=hh[7:4]+4'd1;
																end
															if(hh[3:0] == 4'd1 && hh[7:4]==4'd1)
																begin
																	pm<=~pm;
																	hh[3:0]<=4'd2;
																	hh[7:4]<=4'd1;
																end
															if(hh[3:0] == 4'd2 && hh[7:4]==4'd1)
																begin
																	hh[3:0]<=4'd1;
																	hh[7:4]<=4'd0;
																end
														end
												end
										end
								end
						end
				end
		endmodule"
	},{
		"id": "22",
		"instruction": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second). reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.",
		"module_declaration": "
		module top_module(
			input clk,
			input reset,
			input ena,
			output pm,
			output [7:0] hh,
			output [7:0] mm,
			output [7:0] ss
		);",
		"output": "
		module top_module(
			input clk,
			input reset,
			input ena,
			output pm,
			output [7:0] hh,
			output [7:0] mm,
			output [7:0] ss
		); 
    
			always@(posedge clk) begin
				if (reset) begin
					hh <= 8'h12;
					mm <= 0;
					ss <= 0;
					pm <= 0;
				end
				else begin
					if (ena) begin
						pm <= (hh == 8'h11 && mm == 8'h59 && ss == 8'h59)? ~pm : pm;
						if (ss == 8'h59) begin // ss = 59
							ss <= 0;
							
							if (mm == 8'h59) begin // mm = 59
								mm <= 0;
								
								if (hh == 8'h12) begin
									hh <= 8'h01;
								end
								
								else begin
									if (hh[3:0] == 4'd9) begin
										hh[3:0] <= 0;
										hh[7:4] <= hh[7:4] + 4'd1;
									end
									else 
										hh[3:0] <= hh[3:0] + 4'd1;  
								end
				
							end
							else begin
								if (mm[3:0] == 4'd9) begin
									mm[3:0] <= 0;
									mm[7:4] <= mm[7:4] + 4'd1;
								end
								else 
									mm[3:0] <= mm[3:0] + 4'd1; 
							end
							
							
						end
						else begin
							if (ss[3:0] == 4'd9) begin
								ss[3:0] <= 0;
								ss[7:4] <= ss[7:4] + 4'd1;
							end
							else 
								ss[3:0] <= ss[3:0] + 4'd1;
						end
					end   
				end
			end
		
		endmodule"
	},{
		"id": "23",
		"instruction": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is "random access", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers.",
		"module_declaration": "
		module top_module (
			input clk,
			input enable,
			input S,
			input A, B, C,
			output Z 
		);",
		"output": "
		module top_module (
			input clk,
			input enable,
			input S,
			input A, B, C,
			output Z
		); 

			reg[7:0] q;

			always @(posedge clk) begin
				if(enable)
					q <= {q[6:0], S};	
				else 
			q <= q;
			end
		
			always @(*) begin
			case({A, B, C})
				3'b000 : Z = q[0];
				3'b001 : Z = q[1];
				3'b010 : Z = q[2];
				3'b011 : Z = q[3];
				3'b100 : Z = q[4];
				3'b101 : Z = q[5];
				3'b110 : Z = q[6];
				3'b111 : Z = q[7];
			endcase
			end
		
		endmodule"
	},{
		"id": "24",
		"instruction": "Conway's Game of Life is a two-dimensional cellular automaton. The "game" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:
		
		- 0-1 neighbour: Cell becomes 0.
		- 2 neighbours: Cell state does not change.
		- 3 neighbours: Cell becomes 1.
		- 4+ neighbours: Cell becomes 0.
		
		The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. (This tool accepts SystemVerilog, so you may use 2D vectors if you wish.)
		
		- load: Loads data into q at the next clock edge, for loading initial state.
		- q: The 16x16 current state of the game, updated every clock cycle.

		The game state should advance by one timestep every clock cycle. ",
		"module_declaration": "
		module top_module(
			input clk,
			input load,
			input [255:0] data,
			output [255:0] q 
		);",
		"output": "
		module rule (
			input [7:0] neigh,
			input current,
			output next 
		);
		
			wire [2:0] pop;
			assign pop = {2'b00, neigh[0]} +
						{2'b00, neigh[1]} +
						{2'b00, neigh[2]} +
						{2'b00, neigh[3]} +
						{2'b00, neigh[4]} +
						{2'b00, neigh[5]} +
						{2'b00, neigh[6]} +
						{2'b00, neigh[7]}; 
			
			reg tmp;
			assign next = tmp;
		
			always @(*) begin
				case (pop)
					2: tmp = current;
					3: tmp = 1;
					default: tmp = 0;
				endcase
			end
		endmodule
		
		module top_module(
			input clk,
			input load,
			input [255:0] data,
			output [255:0] q ); 
			
			wire [255:0] next;
			
			genvar x, y;
			generate
				for (x=0; x<=15; x=x+1) begin : gen_x
					for (y=0; y<=15; y=y+1) begin : gen_y
						rule fate (
							.neigh({q[(x==0 ? 15 : x-1) + (y==0 ? 15 : y-1)*16],
									q[(x==0 ? 15 : x-1) + y                *16],
									q[(x==0 ? 15 : x-1) + (y==15 ? 0 : y+1)*16],
									q[x                 + (y==0 ? 15 : y-1)*16],
									q[x                 + (y==15 ? 0 : y+1)*16],
									q[(x==15 ? 0 : x+1) + (y==0 ? 15 : y-1)*16],
									q[(x==15 ? 0 : x+1) + y                *16],
									q[(x==15 ? 0 : x+1) + (y==15 ? 0 : y+1)*16]}),
							.current(q[(x + y*16)]),
							.next(next[(x + y*16)])
						);
					end
				end
			endgenerate
			
			always @(posedge clk) begin
				if (load) begin
					q <= data;
				end else begin
					q <= next;
				end
			end
		endmodule"
	},{
		"id": "25",
		"instruction": "Conway's Game of Life is a two-dimensional cellular automaton. The "game" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:
		
		- 0-1 neighbour: Cell becomes 0.
		- 2 neighbours: Cell state does not change.
		- 3 neighbours: Cell becomes 1.
		- 4+ neighbours: Cell becomes 0.
		
		The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. (This tool accepts SystemVerilog, so you may use 2D vectors if you wish.)
		
		- load: Loads data into q at the next clock edge, for loading initial state.
		- q: The 16x16 current state of the game, updated every clock cycle.

		The game state should advance by one timestep every clock cycle. ",
		"module_declaration": "
		module top_module(
			input clk,
			input load,
			input [255:0] data,
			output [255:0] q 
		);",
		"output": "
		module top_module(
			input clk,
			input load,
			input [255:0] data,
			output [255:0] q 
		); 
			
			reg [255:0] temp;
			wire [287:0] map = {temp[15:0],temp,temp[255:240]};
			int count;
			
			always@(posedge clk) begin
				if(load) begin
					q <= data;
				end
				else begin
					for (int i = 16; i < 272; i = i+1) begin
						if(i == 16 || i == 32 || i == 48 || i == 64 || i == 80 || i == 96 || i==112 || i==128 || i == 144
						|| i == 160 || i == 176 || i == 192 || i == 208 || i == 224 || i == 240 || i == 256) begin
							count = map[i+1]+map[i+15]+map[i+16]+map[i+17]+map[i+31]+map[i-1]+map[i-15]+map[i-16];
						end
						else if (i == 31 || i == 47 || i == 63 || i == 79 || i == 95 || i==111 || i==127 || i == 143
						|| i == 159 || i == 175 || i == 191 || i == 207 || i == 223 || i == 239 || i == 255 || i == 271) begin
							count = map[i-1]+map[i-15]+map[i-16]+map[i-17]+map[i-31]+map[i+1]+map[i+15]+map[i+16];
						end
						else begin
							count = map[i+1]+map[i+15]+map[i+16]+map[i+17]+map[i-1]+map[i-15]+map[i-16]+map[i-17];
						end
						
						if(count == 2)
							q[i-16] <= q[i-16];
						else if(count == 3)
							q[i-16] <= 1'b1;
						else
							q[i-16] <= 1'b0;
					end
				end
				
			end
			
			always@(negedge clk) begin
				temp <= q;
			end
		endmodule"
	},{
		"id": "26",
		"instruction": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

		- State: A, Next state if in = 0: A, Next state if in = 1: B, Output: 0
		- State: B, Next state if in = 0: C, Next state if in = 1: B, Output: 0
		- State: C, Next state if in = 0: A, Next state if in = 1: D, Output: 0
		- State: D, Next state if in = 0: C, Next state if in = 1: B, Output: 1",
		"module_declaration": "
		module top_module(
			input in,
			input [1:0] state,
			output [1:0] next_state,
			output out
		);",
		"output": "
		module top_module(
			input in,
			input [1:0] state,
			output [1:0] next_state,
			output out
			); 

			parameter A=2'd0, B=2'd1, C=2'd2, D=2'd3;
			
			always@(*)
				begin
					case(state)
						A: next_state <=in?B:A;
						B: next_state <=in?B:C;
						C: next_state <=in?D:A;
						D: next_state <=in?B:C;
					endcase
				end
				
			assign out = (state == D);
		endmodule"
	},{
		"id": "27",
		"instruction": "Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.
		- State: 000, Next state if input x=0: 000, Next state if input x=1: 001, Output z: 0
		- State: 001, Next state if input x=0: 001, Next state if input x=1: 100, Output z: 0
		- State: 010, Next state if input x=0: 010, Next state if input x=1: 001, Output z: 0
		- State: 011, Next state if input x=0: 001, Next state if input x=1: 010, Output z: 1
		- State: 100, Next state if input x=0: 011, Next state if input x=1: 100, Output z: 1",
		"module_declaration": "
		module top_module (
			input clk,
			input reset,   // Synchronous reset
			input x,
			output z
		);",
		"output": "
		module top_module (
			input clk,
			input reset,   // Synchronous reset
			input x,
			output z
		);
		
			parameter a = 0, b = 1, c = 2, d = 3, e = 4;
			reg [2:0] state, next_state;
		
			always @(*) begin
				case (state)
					a: next_state = x ? b : a;
					b: next_state = x ? e : b;
					c: next_state = x ? b : c;
					d: next_state = x ? c : b;
					e: next_state = x ? e : d;
				endcase
			end
		
			always @(posedge clk) begin
				if (reset) begin
					state <= a;
				end
				else begin
					state <= next_state;
				end
			end
		
			assign z = (state == d || state == e);
		
		endmodule"
	},{
		"id": "28",
		"instruction": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset). ",
		"module_declaration": "
		module top_module (
			input clk,
			input resetn,    // active-low synchronous reset
			input x,
			input y,
			output f,
			output g
		);",
		"output": "
		module top_module (
			input clk,
			input resetn,    // active-low synchronous reset
			input x,
			input y,
			output reg f,
			output reg g
		); 
		
			parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
			reg [3:0] state, next_state;
			
			always@(*) begin
				case(state)
					A: begin
						if(resetn) 
							next_state = f1;
						else
							next_state = A;
					end
					f1:     next_state = tmp0;
					tmp0: begin
						if(x)
							next_state = tmp1;
						else
							next_state = tmp0;
					end
					tmp1: begin
						if(~x)
							next_state = tmp2;
						else
							next_state = tmp1;
					end
					tmp2: begin
						if(x)
							next_state = g1;
						else
							next_state = tmp0;
					end
					g1: begin
						if(y)
							next_state = g1p;
						else
							next_state = tmp3;
					end
					tmp3: begin
						if(y)
							next_state = g1p;
						else
							next_state = g0p;
					end
					g1p: begin
						if(~resetn)
							next_state = A;
						else
							next_state = g1p;
					end
					g0p: begin
						if(~resetn)
							next_state = A;
						else
							next_state = g0p;
					end
				endcase
			end
			
			always@(posedge clk) begin
				if(~resetn)
					state <= A;
				else
					state <= next_state;
			end
			
			always@(posedge clk) begin
				case(next_state)
					f1:     f <= 1'b1;
					g1:		g <= 1'b1;
					tmp3:	g <= 1'b1;
					g1p:    g <= 1'b1;
					g0p:    g <= 1'b0;
					default: begin
							f <= 1'b0;
							g <= 1'b0;
					end
				endcase
			end
		
		endmodule"
	},{
		"id": "29",
		"instruction": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.",
		"module_declaration": "
		module top_module (
			input clk,
			input reset,
			output [9:0] q
		);",
		"output": "
		module top_module (
			input clk,
			input reset,
			output [9:0] q
		);
    
			always @(posedge clk) begin
				if (reset) q <= 0;
				else begin
				if (q < 999) q <= q + 1'b1;
					else q <= 0;
				end
			end
	
		endmodule"
	},{
		"id": "30",
		"instruction": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).",
		"module_declaration": "
		module top_module (
			input clk,
			input shift_ena,
			input count_ena,
			input data,
			output [3:0] q
		);",
		"output": "
		module top_module (
			input clk,
			input shift_ena,
			input count_ena,
			input data,
			output [3:0] q
		);
		
			reg [3:0] shift_temp;
		
			always @(posedge clk) begin
				if (shift_ena) begin
					shift_temp <= {shift_temp[2:0], data};
				end
				else if (count_ena) begin
					shift_temp <= shift_temp - 1'b1;
				end 
			end
		
			assign q = shift_temp;
			
		endmodule"
	},{
		"id": "31",
		"instruction": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).",
		"module_declaration": "
		module top_module (
			input clk,
			input shift_ena,
			input count_ena,
			input data,
			output [3:0] q
		);",
		"output": "
		module top_module (
			input clk,
			input shift_ena,
			input count_ena,
			input data,
			output [3:0] q
		);
			
			always@(posedge clk)begin
				if(shift_ena)begin
					q <= {q[2:0], data};
				end
				else if(count_ena)begin
					q <= q - 1'b1;
				end
			end
		
		endmodule"
	},{
		"id": "32",
		"instruction": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented.",
		"module_declaration": "
		module top_module (
			input clk,
			input reset,      // Synchronous reset
			input data,
			output start_shifting
		);",
		"output": "
		module top_module (
			input clk,
			input reset,      // Synchronous reset
			input data,
			output start_shifting
		);
		
			localparam [2:0] IDLE = 0,
							S1   = 1,
							S11  = 2,
							S110 = 3,
							S1101= 4;
		
			reg [2:0] state, next;
		
			always @(*) begin
				case (state)
					IDLE  : next = (data) ? S1   : IDLE;
					S1    : next = (data) ? S11  : IDLE;
					S11   : next = (data) ? S11  : S110;
					S110  : next = (data) ? S1101: IDLE;
					S1101 : next = S1101;
				endcase
			end
		
			always @(posedge clk) begin
				if (reset) begin
					state <= IDLE;
				end
				else state <= next;
			end
		
			assign start_shifting = (state == S1101);
		endmodule"
	},{
		"id": "33",
		"instruction": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them.

		- load: Loads shift register with data[99:0] instead of rotating.
		- ena[1:0]: Chooses whether and which direction to rotate:
			- 2'b01 rotates right by one bit
			- 2'b10 rotates left by one bit
			- 2'b00 and 2'b11 do not rotate.
		- q: The contents of the rotator.",
		"module_declaration": "
		module top_module(
			input clk,
			input load,
			input [1:0] ena,
			input [99:0] data,
			output reg [99:0] q
		);",
		"output": "
		module top_module(
			input clk,
			input load,
			input [1:0] ena,
			input [99:0] data,
			output reg [99:0] q
		); 
		
		always@(posedge clk)begin
			if(load) q <= data;
				else begin
						if(ena == 2'b01) q <= {q[0], q[99:1]};
						else if(ena == 2'b10) q<= {q[98:0], q[99]};
						else q <= q;
				end
			end
		
		endmodule"
	},{
		"id": "34",
		"instruction": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount. An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two. There is no difference between logical and arithmetic left shifts.

		- load: Loads shift register with data[63:0] instead of shifting.
		- ena: Chooses whether to shift.
		- amount: Chooses which direction and how much to shift:
			- 2'b00: shift left by 1 bit.
			- 2'b01: shift left by 8 bits.
			- 2'b10: shift right by 1 bit.
			- 2'b11: shift right by 8 bits.
		- q: The contents of the shifter.",
		"module_declaration": "
		module top_module(
			input clk,
			input load,
			input ena,
			input [1:0] amount,
			input [63:0] data,
			output reg [63:0] q
		);",
		"output": "
		module top_module(
			input clk,
			input load,
			input ena,
			input [1:0] amount,
			input [63:0] data,
			output reg [63:0] q
		);
		
		always @(posedge clk) begin
				if(load) q <= data;
				else begin
					if(ena) begin
						if(amount == 2'b00) 
					q <= (q << 1);
						else if(amount == 2'b01) 
					q <= (q << 8);
						else if(amount == 2'b10) begin
							if(q[63] == 0) 
						q <= (q >> 1);
							else begin
									q <= (q >> 1);
									q[63] <= 1'b1;
							end
						end
						else begin
							if(q[63] == 0) 
						q <= (q >> 8);
							else begin
									q <= (q >> 8);
									q[63:56] <= {8{1'b1}};
							end
						end
					end
				end
			end
		
		endmodule"
	},{
		"id": "35",
		"instruction": "Implement a Mealy-type finite state machine that recognizes the sequence "101" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the "101" sequence is detected. Your FSM should also have an active-low asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.",
		"module_declaration": "
		module top_module (
			input clk,
			input aresetn,    // Asynchronous active-low reset
			input x,
			output z 
		);",
		"output": "
		module top_module (
			input clk,
			input aresetn,    // Asynchronous active-low reset
			input x,
			output z 
		); 
		
			localparam [1:0] IDLE     = 0,
							ONE      = 1,
							ONE_ZERO = 2;
		
			reg [1:0] state, next;
		
			always @(*) begin
				case (state)
					IDLE : begin 
						next = (x) ? ONE : IDLE;
						z = 0;
					end
					ONE : begin
						next = (x) ? ONE : ONE_ZERO;
						z = 0;
					end
					ONE_ZERO : begin
						if (x) begin
							next = ONE;
							z = 1;
						end
						else begin
							next = IDLE;
							z = 0;
						end
					end
				endcase
			end
		
			always @(posedge clk or negedge aresetn) begin
				if (~aresetn) state <= IDLE;
				else state <= next;
			end
		
		endmodule"
	},{
		"id": "36",
		"instruction": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk. ",
		"module_declaration": "
		module top_module (
			input clk,
			input resetn,
			input [1:0] byteena,
			input [15:0] d,
			output [15:0] q
		);",
		"output": "
		module top_module (
			input clk,
			input resetn,
			input [1:0] byteena,
			input [15:0] d,
			output [15:0] q
		);
			always@(posedge clk)begin
				if(!resetn)
					q <= 0;
				else begin
					if(byteena[0])
						q[7:0] <= d[7:0];
					else 
						q[7:0] <= q[7:0];
					if(byteena[1])
						q[15:8] <= d[15:8];
					else 
						q[15:8] <= q[15:8];
				end
			end
		endmodule"
	},{
		"id": "37",
		"instruction": "A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.
		- J:0 K:0 Q=Qold
		- J:0 K:1 Q=0
		- J:1 K:0 Q=1
		- J:1 K:1 Q=~Qold",
		"module_declaration": "
		module top_module (
			input clk,
			input j,
			input k,
			output Q
		);",
		"output": "
		module top_module (
			input clk,
			input j,
			input k,
			output Q
		); 
			
			always @(posedge clk) begin
				case({j, k})
					2'b00 : Q <= Q;
					2'b01 : Q <= 0;
					2'b10 : Q <= 1;
					2'b11 : Q <= ~Q;
				endcase
			end
		
		endmodule"
	},{
		"id": "38",
		"instruction": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.
			  | ab=00 | ab=01 | ab=11 | ab=10 |
		cd=00 | out=d | out=0 | out=1 | out=1 |
		cd=01 | out=0 | out=0 | out=d | out=d |
		cd=11 | out=0 | out=1 | out=1 | out=1 |
		cd=10 | out=0 | out=1 | out=1 | out=1 |",
		"module_declaration": "
		module top_module(
			input a,
			input b,
			input c,
			input d,
			output out  
		);",
		"output": "
		module top_module(
			input a,
			input b,
			input c,
			input d,
			output out  
		);
		
		assign out = a | (c & ~b);
		
		endmodule"
	},{
		"id": "39",
		"instruction": "Implement the following state machine, which has one input w, one output z, and 6 states A, B, C, D, E, F:
		Curr State | Next State if w=0 | Next State if w=1 | Output |
		A | B | A | 0 |
		B | C | D | 0 |
		C | E | D | 0 |
		D | F | A | 0 |
		E | E | D | 1 |
		F | C | D | 1 |",
		"module_declaration": "
		module top_module (
			input clk,
			input reset,     // synchronous reset
			input w,
			output z
		);",
		"output": "
		module top_module (
			input clk,
			input reset,     // synchronous reset
			input w,
			output z
		);
		
			parameter a=3'b000, b=3'b001, c=3'b010, d=3'b011, e=3'b100, f=3'b101;
			reg [2:0] state, next_state;
			
			always@(*) begin
				case({state, w})
					{a, 1'b0}:  next_state = b;
					{a, 1'b1}:  next_state = a;
					{b, 1'b0}:  next_state = c;
					{b, 1'b1}:  next_state = d;
					{c, 1'b0}:  next_state = e;
					{c, 1'b1}:  next_state = d;
					{d, 1'b0}:  next_state = f;
					{d, 1'b1}:  next_state = a;
					{e, 1'b0}:  next_state = e;
					{e, 1'b1}:  next_state = d;
					{f, 1'b0}:  next_state = c;
					{f, 1'b1}:  next_state = d;
					default  :  next_state = a;
				endcase
			end
			
			always@(posedge clk) begin
				if(reset)
					state <= a;
				else
					state <= next_state;
			end
			
			assign z = (state == e || state == f);
			
		endmodule"
	},{
		"id": "40",
		"instruction": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.",
		"module_declaration": "
		module top_module (
			input clk,
			input reset,   // Synchronous reset
			input s,
			input w,
			output z
		);",
		"output": "
		module top_module (
			input clk,
			input reset,   // Synchronous reset
			input s,
			input w,
			output z
		);
		parameter A = 0, B = 1;
		
		reg state, next;
			reg [1:0] count;
			reg [1:0] count1;
		
			always @(*) begin
				case(state)
					A : next = (s) ? B : A;
					B : next = B;
		endcase
		end
		
		always @(posedge clk) begin
		if (reset) begin
		state <= A;
					count=0;
					count1=0;
		end
		else begin 
			state <= next;
				
				if(state==B)
					begin
						if(count1==3)begin
							count=0;
							count1=0;
						end
						if(w==1) count=count+1;
						
							count1=count1+1;
						
					end
			end
		end    
		
		
		
			assign z = ((count == 2) & (count1 == 3) );
		endmodule"
	},{
		"id": "41",
		"instruction": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. ",
		"module_declaration": "
		module top_module(
			input clk,
			input [7:0] in,
			input reset,    // Synchronous reset
			output done
		);",
		"output": "
		module top_module(
			input clk,
			input [7:0] in,
			input reset,    // Synchronous reset
			output done
		);
		
			localparam [1:0] BYTE1 = 2'b00,
							BYTE2 = 2'b01,
							BYTE3 = 2'b10,
							DONE  = 2'b11;
		
			reg [1:0] state, next;
		
			// State transition logic (combinational)
			always @(*) begin
				case(state)
					BYTE1 : next = (in[3]) ? BYTE2 : BYTE1;
					BYTE2 : next = BYTE3;
					BYTE3 : next = DONE;
					DONE  : next = (in[3]) ? BYTE2 : BYTE1;
				endcase
			end
		
			// State flip-flops (sequential)
			always @(posedge clk) begin
				if(reset) state <= BYTE1;
				else state <= next;
			end
		
			// Output logic
			assign done = (state == DONE);
		
		endmodule"
	},{
		"id": "42",
		"instruction": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			output walk_left,
			output walk_right
		);",
		"output": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			output walk_left,
			output walk_right
		); //  
		
			parameter LEFT = 0, RIGHT = 1;
			reg state, next_state;
		
			always @(*) begin
				// State transition logic
				case(state)
					LEFT : next_state = (bump_left) ? RIGHT : LEFT;
					RIGHT : next_state = (bump_right) ? LEFT : RIGHT;
				endcase
			end
		
			always @(posedge clk, posedge areset) begin
				// State flip-flops with asynchronous reset
				if(areset) state <= LEFT;
				else begin
					state <= next_state;
				end
			end
		
			// Output logic
			assign walk_left = (state == LEFT);
			assign walk_right = (state == RIGHT);
		
		endmodule"
	},{
		"id": "43",
		"instruction": "_description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction. Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			output walk_left,
			output walk_right,
			output aaah 
		);",
		"output": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			output walk_left,
			output walk_right,
			output aaah 
		); 
		
			localparam [1:0] WALK_L = 2'b00,
							WALK_R = 2'b01,
							FALL_L = 2'b10,
							FALL_R = 2'b11;
		
			reg [1:0] state, next;
		
			always @(posedge clk or posedge areset) begin
				if(areset) state <= WALK_L;
				else begin
					state <= next;
				end
			end
		
			always @(*) begin
				case(state)
					WALK_L : next = (ground == 0) ? FALL_L : ((bump_left == 1) ? WALK_R : WALK_L);
					WALK_R : next = (ground == 0) ? FALL_R : ((bump_right == 1) ? WALK_L : WALK_R);
					FALL_L : next = (ground == 1) ? WALK_L : FALL_L;
					FALL_R : next = (ground == 1) ? WALK_R : FALL_R;
				endcase
			end
		
			assign walk_left = (state == WALK_L);
			assign walk_right = (state == WALK_R);
			assign aaah = ((state == FALL_L) || (state == FALL_R));
		
		endmodule"
	},{
		"id": "44",
		"instruction": ": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction. In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.) Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			input dig,
			output walk_left,
			output walk_right,
			output aaah,
			output digging 
		);",
		"output": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			input dig,
			output walk_left,
			output walk_right,
			output aaah,
			output digging 
		); 
		
			localparam [2:0] WALK_L = 3'b000,
							WALK_R = 3'b001,
							FALL_L = 3'b010,
							FALL_R = 3'b011,
							DIG_L  = 3'b100,
							DIG_R  = 3'b101;
		
			reg [2:0] state, next;
		
			always @(posedge clk or posedge areset) begin
				if(areset) state <= WALK_L;
				else state <= next;
			end
		
			always @(*) begin
				case(state)
					WALK_L : begin
						if(!ground) next = FALL_L;
						else begin
							if(dig) next = DIG_L;
							else begin
								if(bump_left) next = WALK_R;
								else next = WALK_L;
							end
						end
					end
					WALK_R : begin
						if(!ground) next = FALL_R;
						else begin
							if(dig) next = DIG_R;
							else begin
								if(bump_right) next = WALK_L;
								else next = WALK_R;
							end
						end
					end
					FALL_L : next = (ground) ? WALK_L : FALL_L;
					FALL_R : next = (ground) ? WALK_R : FALL_R;
					DIG_L  : next = (ground) ? DIG_L : FALL_L;
					DIG_R  : next = (ground) ? DIG_R : FALL_R;
				endcase
			end
		
			assign walk_left = (state == WALK_L);
			assign walk_right = (state == WALK_R);
			assign aaah = ((state == FALL_L) || (state == FALL_R));
			assign digging = ((state == DIG_L) || (state == DIG_R));
		
		endmodule"
	},{
		"id": "45",
		"instruction": ": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction. In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.) Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			input dig,
			output walk_left,
			output walk_right,
			output aaah,
			output digging 
		);",
		"output": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			input dig,
			output walk_left,
			output walk_right,
			output aaah,
			output digging 
		); 
			parameter LEFT=3'd0, RIGHT=3'd1, GROUND_LEFT=3'd2,  GROUND_RIGHT=3'd3, DIG_LEFT=3'd4, DIG_RIGHT=3'd5;
			reg [2:0] state,next_state;
			always@(posedge clk or posedge areset)
				begin
					if(areset) state<=LEFT;
					else state<=next_state;
				end
			always@(*)
				begin
					case(state)
						3'd0: begin next_state<=(!ground)?GROUND_LEFT:(dig?DIG_LEFT:(bump_left?RIGHT:LEFT));end
						3'd1: begin next_state<=(!ground)?GROUND_RIGHT:(dig?DIG_RIGHT:(bump_right?LEFT:RIGHT)); end
						3'd2:next_state<=ground?LEFT:GROUND_LEFT;
						3'd3:next_state<=ground?RIGHT:GROUND_RIGHT;
						3'd4:next_state<=(!ground)?GROUND_LEFT:DIG_LEFT;
						3'd5:next_state<=(!ground)?GROUND_RIGHT:DIG_RIGHT;
						default:next_state<=LEFT;
					endcase
				end
			assign walk_left = (state == LEFT)?1'b1:1'b0;
			assign walk_right = (state == RIGHT)?1'b1:1'b0;
			assign aaah = ((state == GROUND_LEFT) || (state == GROUND_RIGHT))?1'b1:1'b0;
			assign digging = ((state == DIG_LEFT) || (state == DIG_RIGHT))?1'b1:1'b0;
		endmodule"
	},{
		"id": "46",
		"instruction": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction. In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.) Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air. Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			input dig,
			output walk_left,
			output walk_right,
			output aaah,
			output digging 
		);",
		"output": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			input dig,
			output walk_left,
			output walk_right,
			output aaah,
			output digging 
		); 
		
			localparam [2:0] WALK_L = 3'b000,
							WALK_R = 3'b001,
							FALL_L = 3'b010,
							FALL_R = 3'b011,
							DIG_L  = 3'b100,
							DIG_R  = 3'b101,
							SPLATTER = 3'b110;
		
			reg [2:0] state, next;
			reg [6:0] count;
		
			always @(posedge clk or posedge areset) begin
				if(areset) state <= WALK_L;
				else if(state == FALL_R || state == FALL_L) begin
					count <= count + 1;
					state <= next;
				end
				else begin
					state <= next;
					count <= 0;
				end       
			end
		
			always @(*) begin
				case(state)
					WALK_L : begin
						if(!ground) next = FALL_L;
						else begin
							if(dig) next = DIG_L;
							else begin
								if(bump_left) next = WALK_R;
								else next = WALK_L;
							end
						end
					end
					WALK_R : begin
						if(!ground) next = FALL_R;
						else begin
							if(dig) next = DIG_R;
							else begin
								if(bump_right) next = WALK_L;
								else next = WALK_R;
							end
						end
					end
					FALL_L : begin
						if(ground) begin
							if(count > 19) next = SPLATTER;
							else next = WALK_L;
						end
						else next = FALL_L;
					end
					FALL_R : begin
						if(ground) begin
							if(count > 19) next = SPLATTER;
							else next = WALK_R;
						end
						else next = FALL_R;
					end
					DIG_L  : next = (ground) ? DIG_L : FALL_L;
					DIG_R  : next = (ground) ? DIG_R : FALL_R;
					SPLATTER : next = SPLATTER;
				endcase
			end
		
			assign walk_left = (state == WALK_L);
			assign walk_right = (state == WALK_R);
			assign aaah = ((state == FALL_L) || (state == FALL_R));
			assign digging = ((state == DIG_L) || (state == DIG_R));
		
		endmodule"
	},{
		"id": "47",
		"instruction": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction. In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.) Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air. Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			input dig,
			output walk_left,
			output walk_right,
			output aaah,
			output digging 
		);",
		"output": "
		module top_module(
			input clk,
			input areset,    // Freshly brainwashed Lemmings walk left.
			input bump_left,
			input bump_right,
			input ground,
			input dig,
			output walk_left,
			output walk_right,
			output aaah,
			output digging ); 
			parameter LEFT=3'd0, RIGHT=3'd1, GROUND_LEFT=3'd2,  GROUND_RIGHT=3'd3, DIG_LEFT=3'd4, DIG_RIGHT=3'd5, SPLATTER = 3'd6, OOPS=3'd7;
			reg [2:0] state,next_state;
			reg [4:0]q;
			always@(posedge clk or posedge areset)
				begin
					if(areset) q<=5'd0;
					else if(next_state == GROUND_LEFT || next_state == GROUND_RIGHT) q<=q+5'd1;
					else q<=5'd0;
				end
			always@(posedge clk or posedge areset)
				begin
					if(areset) state<=LEFT;
					else state<=next_state;
				end
			always@(*)
				begin
					case(state)
						3'd0: begin next_state<=(!ground)?GROUND_LEFT:(dig?DIG_LEFT:(bump_left?RIGHT:LEFT));end
						3'd1: begin next_state<=(!ground)?GROUND_RIGHT:(dig?DIG_RIGHT:(bump_right?LEFT:RIGHT)); end
						3'd2:next_state<=ground?LEFT:((q == 5'd20)?SPLATTER:GROUND_LEFT);
						3'd3:next_state<=ground?RIGHT:((q == 5'd20)?SPLATTER:GROUND_RIGHT);
						3'd4:next_state<=(!ground)?GROUND_LEFT:DIG_LEFT;
						3'd5:next_state<=(!ground)?GROUND_RIGHT:DIG_RIGHT;
						3'd6:next_state<=ground?OOPS:SPLATTER;
						3'd7:next_state<=OOPS;
						default:next_state<=LEFT;
					endcase
				end
			assign walk_left = (state == LEFT)?1'b1:1'b0;
			assign walk_right = (state == RIGHT)?1'b1:1'b0;
			assign aaah = ((state == GROUND_LEFT) || (state == GROUND_RIGHT) || (state == SPLATTER))?1'b1:1'b0;
			assign digging = ((state == DIG_LEFT) || (state == DIG_RIGHT))?1'b1:1'b0;
		endmodule"
	},{
		"id": "48",
		"instruction": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.",
		"module_declaration": "
		module top_module(
			input in,
			input [9:0] state,
			output [9:0] next_state,
			output out1,
			output out2
		);",
		"output": "
		module top_module(
			input in,
			input [9:0] state,
			output [9:0] next_state,
			output out1,
			output out2
		);
		
			localparam  S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4,
						S5 = 5, S6 = 6, S7 = 7, S8 = 8, S9 = 9;
		
			//states
			assign next_state[S0] = (state[S0] & !in) | (state[S1] & !in) | (state[S2] & !in) | (state[S3] & !in) | 
									(state[S4] & !in) | (state[S7] & !in) | (state[S8] & !in) | (state[S9] & !in);
			assign next_state[S1] = (state[S0] & in) | (state[S8] & in) | (state[S9] & in);
			assign next_state[S2] = state[S1] & in;
			assign next_state[S3] = state[S2] & in;
			assign next_state[S4] = state[S3] & in;
			assign next_state[S5] = state[S4] & in;
			assign next_state[S6] = state[S5] & in;
			assign next_state[S7] = (state[S6] & in) | (state[7] & in);
			assign next_state[S8] = state[S5] & !in;
			assign next_state[S9] = state[S6] & !in;
		
			//output
			assign out1 = state[8] | state[9];
			assign out2 = state[7] | state[9];
		
		endmodule"
	},{
		"id": "49",
		"instruction": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.",
		"module_declaration": "
		module top_module(
			input clk,
			input reset,    // Active-high synchronous reset to 5'h1
			output [4:0] q
		);",
		"output": "
		module top_module(
			input clk,
			input reset,    
			output [4:0] q
		); 
			always @(posedge clk) begin
				if(reset) 
				q <= 5'h1;
				else 
				q <= {q[0]^1'b0, q[4], q[3]^q[0], q[2], q[1]};
			end
		
		endmodule"
	},{
		"id": "50",
		"instruction": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.",
		"module_declaration": "
		module top_module(
			input clk,
			input reset,    // Active-high synchronous reset to 32'h1
			output [31:0] q
		);",
		"output": "
		module top_module(
			input clk,
			input reset,   
			output [31:0] q
		);
		
		always @(posedge clk) begin
			if(reset) 
				q <= 32'h1;
			else begin
				q <= {0^q[0], q[31:23], q[22]^q[0], q[21:3], q[2]^q[0], q[1]^q[0]};
			end
		end
		endmodule"
	},{
		"id": "51",
		"instruction": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ",
		"module_declaration": "
		module top_module (
			input a,
			input b,
			input c,
			input d,
			output q 
		);",
		"output": "
		module top_module (
			input a,
			input b,
			input c,
			input d,
			output q 
		);
		
			assign q = (b & d) | (b & c) | (a & d) | (a & c);
		
		endmodule"
	},{
		"id": "52",
		"instruction": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ",
		"module_declaration": "
		module top_module (
			input [2:0] a,
			output [15:0] q 
		);",
		"output": "
		module top_module (
			input [2:0] a,
			output reg [15:0] q 
		); 
			
			always@(*)begin
				case(a)
					0 : q = 16'h1232;
					1 : q = 16'haee0;
					2 : q = 16'h27d4;
					3 : q = 16'h5a0e;
					4 : q = 16'h2066;
					5 : q = 16'h64ce;
					6 : q = 16'hc526;
					7 : q = 16'h2f19;
				endcase
			end
		
		endmodule"
	},{
		"id": "53",
		"instruction": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.",
		"module_declaration": "
		module top_module(
			input clk,
			input reset,    // Synchronous reset
			input in,
			output disc,
			output flag,
			output err
		);",
		"output": "
		module top_module(
			input clk,
			input reset,    // Synchronous reset
			input in,
			output disc,
			output flag,
			output err
		);
		
			localparam [3:0] NONE = 0,
							ONE  = 1,
							TWO  = 2,
							THREE= 3,
							FOUR = 4,
							FIVE = 5,
							SIX  = 6,
							DISC = 7,
							FLAG = 8,
							ERR  = 9;
		
			reg [3:0] state, next;
		
			always @(*) begin
				case (state)
					NONE : next = (in) ? ONE   : NONE;
					ONE	 : next = (in) ? TWO   : NONE;
					TWO	 : next = (in) ? THREE : NONE;
					THREE: next = (in) ? FOUR  : NONE;
					FOUR : next = (in) ? FIVE  : NONE;
					FIVE : next = (in) ? SIX   : DISC;
					SIX	 : next = (in) ? ERR   : FLAG;
					DISC : next = (in) ? ONE   : NONE;
					FLAG : next = (in) ? ONE   : NONE;
					ERR  : next = (in) ? ERR   : NONE;
				endcase
			end 
		
			always @(posedge clk) begin
				if (reset)
					state <= NONE;
				else 
					state <= next;
			end
		
			assign disc = (state == DISC);
			assign flag = (state == FLAG);
			assign err = (state == ERR);
		
		endmodule"
	},{
		"id": "54",
		"instruction": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. 
		This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.",
		"module_declaration": "
		module top_module (
			input clk,
			input resetn,    // active-low synchronous reset
			input [3:1] r,   // request
			output [3:1] g   // grant
		);",
		"output": "
		module top_module (
			input clk,
			input resetn,    // active-low synchronous reset
			input [3:1] r,   // request
			output [3:1] g   // grant
		); 
		
			parameter a=2'd0, b=2'd1, c=2'd2, d=2'd3;
			reg [1:0] state, next_state;
			
			always@(*) begin
				case(state)
					a: begin
						if(r[1])    next_state = b;
						else if(~r[1] & r[2])   next_state = c;
						else if(~r[1] & ~r[2] & r[3])   next_state = d;
						else    next_state = a;
					end
					b: begin
						if(r[1])    next_state = b;
						else        next_state = a;
					end
					c: begin
						if(r[2])    next_state = c;
						else        next_state = a;
					end
					d: begin
						if(r[3])    next_state = d;
						else        next_state = a;
					end
				endcase
			end
		
			always@(posedge clk) begin
				if(~resetn)
					state <= a;
				else
					state <= next_state;
			end
			
			assign g[1] = (state == b);
			assign g[2] = (state == c);
			assign g[3] = (state == d);
			
			
		endmodule"
	},{
		"id": "55",
		"instruction": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. 
		This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.",
		"module_declaration": "
		module top_module (
			input clk,
			input resetn,    // active-low synchronous reset
			input [3:1] r,   // request
			output [3:1] g   // grant
		);",
		"output": "
		module top_module (
			input clk,
			input reset,   // Synchronous active-high reset
			input w,
			output z
		);
			parameter A=3'd0, B=3'd1, C=3'd2, D=3'd3, E=3'd4, F=3'd5;
			reg [2:0] state,next_state;
			always@(posedge clk)
				begin
					if(reset) state<=A;
					else state<=next_state;
				end
			always@(*)
				begin
					case(state)
						A:begin next_state<=w?B:A;z<=1'b0; end
						B:begin next_state<=w?C:D;z<=1'b0; end
						C:begin next_state<=w?E:D;z<=1'b0; end
						D:begin next_state<=w?F:A;z<=1'b0; end
						E:begin next_state<=w?E:D;z<=1'b1; end
						F:begin next_state<=w?C:D;z<=1'b1; end
						default:next_state<=A;
					endcase
				end
		endmodule"
	},{
		"id": "56",
		"instruction": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,
		
			input  predict_valid,
			input  [6:0] predict_pc,
			output predict_taken,
			output [6:0] predict_history,
		
			input train_valid,
			input train_taken,
			input train_mispredicted,
			input [6:0] train_history,
			input [6:0] train_pc
		);",
		"output": "
		module top_module(
			input clk,
			input areset,
		
			input  predict_valid,
			input  [6:0] predict_pc,
			output reg predict_taken,
			output reg [6:0] predict_history,
		
			input train_valid,
			input train_taken,
			input train_mispredicted,
			input [6:0] train_history,
			input [6:0] train_pc
		);
			
			localparam SNT = 2'd0, WNT = 2'd1, WT = 2'd2, ST = 2'd3;
			
			reg [1:0] PHT [0:127];
			reg [6:0] GHR;
			
			wire [6:0] predict_index = predict_pc ^ GHR;
			
			always @(*) begin
				if(predict_valid) begin
					predict_taken = (PHT[predict_index] >= WT);
					predict_history = GHR;
				end else begin
					predict_taken = 1'b0;
					predict_history = 7'd0;
				end
			end
			
			wire [6:0] train_index = train_pc ^ train_history;
			
			integer i;
			always @(posedge clk or posedge areset) begin
				if(areset) begin
					GHR <= 7'd0;
					for(i = 0; i < 128; i = i+1)
						PHT[i] <= WNT;
				end
				else begin
					if(train_valid) begin
						case(PHT[train_index])
							SNT: PHT[train_index] <= train_taken ? WNT : SNT;
							WNT: PHT[train_index] <= train_taken ? WT : SNT;
							WT:  PHT[train_index] <= train_taken ? ST : WNT;
							ST:  PHT[train_index] <= train_taken ? ST : WT;
						endcase
					end
					if (train_valid && train_mispredicted) begin
						GHR <= {train_history[5:0], train_taken};
					end else if (!(train_valid && train_mispredicted) && predict_valid) begin
						GHR <= {GHR[5:0], predict_taken};
					end
				end
			end
		
		endmodule"
	},{
		"id": "57",
		"instruction": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,
		
			input predict_valid,
			input predict_taken,
			output [31:0] predict_history,
		
			input train_mispredicted,
			input train_taken,
			input [31:0] train_history
		);",
		"output": "
		module top_module(
			input clk,
			input areset,
		
			input predict_valid,
			input predict_taken,
			output reg [31:0] predict_history,
		
			input train_mispredicted,
			input train_taken,
			input reg [31:0] train_history
		);
			
			always @(posedge clk or posedge areset) begin
				if(areset) 
					predict_history <= 32'd0;
				else begin
					if(train_mispredicted) 
						predict_history <= {train_history[30:0],train_taken};
					else if(predict_valid) 
						predict_history <= {predict_history[30:0],predict_taken};
				end
			end
		
		endmodule"
	},{
		"id": "58",
		"instruction": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.",
		"module_declaration": "
		module top_module(
			input clk,
			input areset,
			input train_valid,
			input train_taken,
			output [1:0] state
		);",
		"output": "
		module top_module(
			input clk,
			input areset,
			input train_valid,
			input train_taken,
			output reg [1:0] state
		);
			localparam 	SNT = 2'b00,
						WNT = 2'b01,
						WT = 2'b10,
						ST = 2'b11;
			
			reg [1:0] next;
			
			always @(*) begin
				case(state)
					SNT: next = train_taken ? WNT : SNT;
					WNT: next = train_taken ? WT  : SNT;
					WT:  next = train_taken ? ST  : WNT;
					ST:  next = train_taken ? ST  :  WT;
					default: next = WNT;
				endcase
			end
			
			always @(posedge clk or posedge areset) begin
				if(areset) state <= WNT;
				else state <= train_valid ? next : state;
			end
		
		endmodule"
	}
]