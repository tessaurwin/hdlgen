{"id": "vector_part_select", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nA 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of a 4-byte word.\n\nStarter module:\nmodule top_module( input [31:0] in, output [31:0] out );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nStarter module:\nmodule top_module( input [31:0] in, output [31:0] out );\n\n   Reg#(Bit#(4)) r <- mkReg(0);\n\n   rule rl_reverse;\n      Bit#(4) temp = r[31:24];\n      r[31:24] <= r[23:16];\n      r[23:16] <= temp;\n   endrule\n\n   rule rl_output;\n      out[31:0] <= in;\n   endrule\n\nendmodule\n\nStarter module:\nmodule top_module( input [31:0] in, output [31:0] out );\n\n   Reg#(Bit#(4)) r <- mkReg(0);"}
{"id": "bitwise_operators", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nTwo 3-bit inputs. Compute bitwise-OR, logical-OR, and inverses. Place ~b in out_not[5:3] and ~a in out_not[2:0].\n\nStarter module:\nmodule top_module( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, output [5:0] out_not );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nStarter module:\nmodule top_module( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, output [5:0] out_not );\n\n// Compute bitwise-OR, logical-OR, and inverses\nout_or_bitwise = a[1:0] ^ b[1:0];\nout_or_logical = ~out_or_bitwise;\nout_not = ~out_or_logical;\n\nendmodule\n\nStarter module:\nmodule top_module( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, output [5:0] out_"}
{"id": "four_input_gates", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nCombinational circuit with four inputs in[3:0]. Outputs: out_and=AND of all 4, out_or=OR of all 4, out_xor=XOR of all 4.\n\nStarter module:\nmodule top_module( input [3:0] in, output out_and, output out_or, output out_xor );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\n// Example Verilog code:\nmodule top_module( input [3:0] in, output out_and, output out_or, output out_xor );\n\n   Reg#(Bit#(3)) rg_in <- mkReg(0);\n   Reg#(Bit#(4)) rg_out_and <- mkReg(0);\n   Reg#(Bit#(4)) rg_out_or <- mkReg(0);\n   Reg#(Bit#(4)) rg_out_xor <- mkReg(0);\n\n   rule rl_update_out_and;\n      rg_out_and <= rg_in[2:0];\n   endrule\n\n   rule rl_update_out_or;\n      rg_out_or <= rg_in[1:0];\n   endrule"}
{"id": "vector_concatenation", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nSix 5-bit inputs a..f (30 bits). Four 8-bit outputs w,x,y,z (32 bits). Output is {a,b,c,d,e,f,2'b11}.\n\nStarter module:\nmodule top_module( input [4:0] a, b, c, d, e, f, output [7:0] w, x, y, z );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nExplanation:\nThe top_module module is a simple module that takes six 5-bit inputs (a..f) and four 8-bit outputs (w,x,y,z). The output is a 32-bit register (w) that contains the sum of the inputs. The module is designed to be a simple example of how to use HDL to implement a simple system.\n\nInstructions:\n1. Read the inputs from the inputs port (a..f) and store them in the input array.\n2. Read the inputs from the inputs port (a..f) and store them in the input array.\n3. Read the inputs from the inputs port (a..f) and store them in the input array.\n4. Read the inputs from the inputs port (a..f) and store them in the input array.\n5."}
{"id": "half_adder", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nCreate a half adder. Inputs a,b. Outputs sum, cout.\n\nStarter module:\nmodule top_module( input a, input b, output cout, output sum );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nAssistant module:\nmodule half_adder( input a, input b, output cout, output sum );\n\nreg [1:0] sum_reg;\nreg [1:0] cout_reg;\n\nalways @(posedge clk) begin\n    sum_reg <= sum_reg + b;\n    cout_reg <= sum_reg[1:0];\nend\n\nalways @(posedge clk) begin\n    cout <= sum_reg[0];\nend\n\nendmodule\n\nStarter code:\nmodule top_module;\n\nhalf_adder half_adder_inst;\n\n// Connect inputs and outputs\n\n// Connect clock and reset\n\n// Connect half_adder_inst to inputs\n\n// Connect half_adder_inst to outputs\n\nendmodule\n\nAssistant code:"}
{"id": "full_adder", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nCreate a full adder. Inputs a,b,cin. Outputs sum, cout.\n\nStarter module:\nmodule top_module( input a, input b, input cin, output cout, output sum );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nAssistant module:\nmodule top_module_assistant( input a, input b, input cin, output cout, output sum );\n\n// Write the full finished module below. No commentary. Only code.\n\nendmodule\n\nExplanation:\n\n1. The `top_module` module is a full adder. It takes three inputs (a, b, cin) and outputs two outputs (sum, cout).\n\n2. The `assistant_module` module is a full adder that is identical to the `top_module` module.\n\n3. The `top_module_assistant` module is a stub module that is used to generate the full adder. It is identical to the `assistant_module` module.\n\n4. The `top_module` module is the full adder. It takes three inputs (a,"}
{"id": "mux2_1", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nCreate a 1-bit 2:1 mux. sel=0 chooses a; sel=1 chooses b.\n\nStarter module:\nmodule top_module( input a, input b, input sel, output out );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nStarter module:\nmodule top_module( input a, input b, input sel, output out );\n\nreg [1:0] r;\n\nalways @(posedge clk)\nbegin\n    r <= sel;\nend\n\nif (sel == 0)\n    $display(\"a = %d\", a);\nelse\n    $display(\"b = %d\", b);\n\nout <= r;\n\nendmodule\n\nStarter module:\nmodule top_module( input a, input b, input sel, output out );\n\nreg [1:0] r;\n\nalways @(posedge clk)\nbegin\n    r <= sel;\nend\n\nif (sel == 0)\n    $display(\"a = %d\", a);\nelse\n    $display(\"b = %d\", b);"}
{"id": "mux9_16", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nCreate a 16-bit wide, 9:1 mux. sel=0..8 choose a..i; otherwise out=16'hFFFF.\n\nStarter module:\nmodule top_module( input [15:0] a,b,c,d,e,f,g,h,i, input [3:0] sel, output [15:0] out );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nOutput:\nmodule top_module( input [15:0] a,b,c,d,e,f,g,h,i, input [3:0] sel, output [15:0] out );\n\n   Reg#(Bit#(16)) rg_sel <- mkReg(0, clocked_by clock, reset_by reset);\n   Reg#(Bit#(16)) rg_out <- mkReg(16'hFFFF, clocked_by clock, reset_by reset);\n\n   rule rl_mux;\n      Bit#(16) sel_val = sel[3:0];\n      Bit#(16) out_val = sel_val * 16'h10000000 + rg_sel[15:0];"}
{"id": "thermostat_logic", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nThermostat: mode=1 heat if too_cold; mode=0 cool if too_hot; fan whenever heat or cool is on, or fan_on=1.\n\nStarter module:\nmodule top_module( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nStarter module:\nmodule top_module( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan );\n\n-- Write the full finished module below. No commentary. Only code.\n\nendmodule\n\nStarter module:\nmodule top_module( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan );\n\n-- Write the full finished module below. No commentary. Only code.\n\nendmodule\n\nStarter module:\nmodule top_module( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan );\n\n-- Write the full finished module below. No commentary. Only code.\n\nend"}
{"id": "counter_decade_sync_reset", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\nDecade counter 0..9 with synchronous active-high reset to 0.\n\nStarter module:\nmodule top_module( input clk, input reset, output reg [3:0] q );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nStarter module:\nmodule top_module( input clk, input reset, output reg [3:0] q );\n\n   Reg#(Bit#(3)) counter <- mkReg(0, clocked_by clk, reset_by reset);\n\n   rule increment_counter;\n      counter <= counter + 1;\n   endrule\n\n   rule output_q(counter == 9);\n      q <= counter;\n   endrule\n\nendmodule\n\nStarter module:\nmodule top_module( input clk, input reset, output reg [3:0] q );\n\n   Reg#(Bit#(3)) counter <- mkReg(0, clocked_by clk, reset_by reset);\n\n   rule increment_counter;\n      counter <= counter + 1;\n   endrule"}
{"id": "dffs_async_reset_8", "prompt": "You are an HDL assistant. Produce **only** SystemVerilog code that completes the module.\nInstruction:\n8 DFFs with active-high asynchronous reset; posedge clk.\n\nStarter module:\nmodule top_module( input clk, input areset, input [7:0] d, output reg [7:0] q );\n\n-- Write the full finished module below. No commentary. Only code.", "gen": "endmodule\n\nStarter module:\nmodule top_module( input clk, input areset, input [7:0] d, output reg [7:0] q );\n\n-- Write the full finished module below. No commentary. Only code.\n\nendmodule\n\nStarter module:\nmodule top_module( input clk, input areset, input [7:0] d, output reg [7:0] q );\n\n-- Write the full finished module below. No commentary. Only code.\n\nendmodule\n\nStarter module:\nmodule top_module( input clk, input areset, input [7:0] d, output reg [7:0] q );\n\n-- Write the full finished module below. No commentary. Only code.\n\nendmodule\n\nStarter module:\nmodule top_module"}
