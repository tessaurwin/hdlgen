[
  {
    "id": "vector_part_select",
    "instruction": "A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of a 4-byte word.",
    "module_declaration": "module top_module( \n\t\t\tinput [31:0] in,\n\t\t\toutput [31:0] out \n\t\t);",
    "output": "module top_module( \n\t\t\tinput [31:0] in,\n\t\t\toutput [31:0] out \n\t\t);\n  \n\t\t\tassign out[31:24] = in[7:0];\n\t\t\tassign out[23:16] = in[15:8];\n\t\t\tassign out[15:8]  = in[23:16];\n\t\t\tassign out[7:0]   = in[31:24];\n\n\t\tendmodule"
  },
  {
    "id": "bitwise_operators",
    "instruction": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.",
    "module_declaration": "module top_module( \n\t\t\tinput [2:0] a,\n\t\t\tinput [2:0] b,\n\t\t\toutput [2:0] out_or_bitwise,\n\t\t\toutput out_or_logical,\n\t\t\toutput [5:0] out_not\n\t\t);",
    "output": "module top_module( \n\t\t\tinput [2:0] a,\n\t\t\tinput [2:0] b,\n\t\t\toutput [2:0] out_or_bitwise,\n\t\t\toutput out_or_logical,\n\t\t\toutput [5:0] out_not\n\t\t);\n  \n\t\t\tassign out_or_bitwise = a | b;\n\t\t\tassign out_or_logical = a || b;\n\t\t\tassign out_not[5:3] = ~(b[2:0]);\n\t\t\tassign out_not[2:0] = ~(a[2:0]);\n\n\t\tendmodule"
  },
  {
    "id": "four_input_gates",
    "instruction": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs:\n\t- out_and: output of a 4-input AND gate.\n    - out_or: output of a 4-input OR gate.\n    - out_xor: output of a 4-input XOR gate.",
    "module_declaration": "module top_module( \n\t\t\tinput [3:0] in,\n\t\t\toutput out_and,\n\t\t\toutput out_or,\n\t\t\toutput out_xor\n\t\t);",
    "output": "module top_module( \n\t\t\tinput [3:0] in,\n\t\t\toutput out_and,\n\t\t\toutput out_or,\n\t\t\toutput out_xor\n\t\t);\n\n\t\t\tassign out_and = (in[3] & in[2] & in[1] & in[0]);\n\t\t\tassign out_or  = (in[3] | in[2] | in[1] | in[0]);\n\t\t\tassign out_xor = (in[3] ^ in[2] ^ in[1] ^ in[0]);\n\n\t\tendmodule"
  },
  {
    "id": "vector_concatenation",
    "instruction": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits.",
    "module_declaration": "module top_module (\n\t\t\tinput [4:0] a, b, c, d, e, f,\n\t\t\toutput [7:0] w, x, y, z \n\t\t);",
    "output": "module top_module (\n\t\t\tinput [4:0] a, b, c, d, e, f,\n\t\t\toutput [7:0] w, x, y, z \n\t\t);\n\n\t\t\tassign {w,x,y,z} = {a,b,c,d,e,f,2'b11};\n\n\t\tendmodule"
  },
  {
    "id": "module_add",
    "instruction": "You are given a module add16 that performs a 16-bit addition. Instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result, after receiving the carry-out from the first adder. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored), but the internal modules need to in order to function correctly. (In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b). The provided module add16 has the following declaration: module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );",
    "module_declaration": "module top_module(\n\t\t\tinput [31:0] a,\n\t\t\tinput [31:0] b,\n\t\t\toutput [31:0] sum\n\t\t);",
    "output": "module top_module(\n\t\t\tinput [31:0] a,\n\t\t\tinput [31:0] b,\n\t\t\toutput [31:0] sum\n\t\t);\n\t\t\twire w,x;\n\t\t\tadd16 a1(a[15:0],b[15:0],1'b0,sum[15:0],w);\n\t\t\tadd16 a2(a[31:16],b[31:16],w,sum[31:16],x);\n\t\tendmodule"
  },
  {
    "id": "5",
    "instruction": "You are given a module add16 that performs a 16-bit addition. Instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result, after receiving the carry-out from the first adder. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored), but the internal modules need to in order to function correctly. (In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b). The provided module add16 has the following declaration: module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );",
    "module_declaration": "module top_module(\n\t\t\tinput [31:0] a,\n\t\t\tinput [31:0] b,\n\t\t\toutput [31:0] sum\n\t\t);",
    "output": "module top_module(\n\t\t\tinput [31:0] a,\n\t\t\tinput [31:0] b,\n\t\t\toutput [31:0] sum\n\t\t);\n  \n\t\t\twire w1;\n\t\t\treg x = 0;\n  \n\t\t\tadd16 inst0(.a(a[15:0]), .b(b[15:0]),  .sum(sum[15:0]),  .cin(x), .cout(w1));\n\t\t\tadd16 inst1(.a(a[31:16]), .b(b[31:16]), .sum(sum[31:16]), .cin(w1));\n\t\tendmodule"
  },
  {
    "id": "6",
    "instruction": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.",
    "module_declaration": "module top_module (\n\t\t\tinput too_cold,\n\t\t\tinput too_hot,\n\t\t\tinput mode,\n\t\t\tinput fan_on,\n\t\t\toutput heater,\n\t\t\toutput aircon,\n\t\t\toutput fan\n\t\t);",
    "output": "module top_module (\n\t\t\tinput too_cold,\n\t\t\tinput too_hot,\n\t\t\tinput mode,\n\t\t\tinput fan_on,\n\t\t\toutput heater,\n\t\t\toutput aircon,\n\t\t\toutput fan\n\t\t);\n    \n\t\t\tassign heater = mode & too_cold;\n\t\t\tassign aircon = (~mode) & too_hot;\n\t\t\tassign fan = fan_on | (heater | aircon);\n\n\t\tendmodule"
  },
  {
    "id": "7",
    "instruction": "A 'population count' circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.",
    "module_declaration": "module top_module( \n\t\t\tinput [2:0] in,\n\t\t\toutput [1:0] out \n\t\t);",
    "output": "module top_module( \n\t\t\tinput [2:0] in,\n\t\t\toutput [1:0] out \n\t\t);\n  \n\t\t\tinteger i;\n    \n\t\t\talways @(*) begin\n\t\t\t\tout = 2'b0;\n\t\t\t\tfor(i = 0; i < 3; i ++) begin\n\t\t\t\t\tif(in[i])\n\t\t\t\t\t\tout = out + 2'b1;\n\t\t\t\tend\n\t\t\tend\n\n\t\tendmodule"
  },
  {
    "id": "8",
    "instruction": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.",
    "module_declaration": "module top_module( \n\t\t\tinput a, b, sel,\n\t\t\toutput out \n\t\t);",
    "output": "module top_module( \n\t\t\tinput a, b, sel,\n\t\t\toutput out \n\t\t);\n  \n\t\t\tassign out = sel ? b : a;\n\n\t\tendmodule"
  },
  {
    "id": "9",
    "instruction": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.",
    "module_declaration": "module top_module( \n\t\t\tinput [15:0] a, b, c, d, e, f, g, h, i,\n\t\t\tinput [3:0] sel,\n\t\t\toutput [15:0] out \n\t\t);",
    "output": "module top_module( \n\t\t\tinput [15:0] a, b, c, d, e, f, g, h, i,\n\t\t\tinput [3:0] sel,\n\t\t\toutput [15:0] out \n\t\t);\n    \n\t\t\talways@(*)begin\n\t\t\t\tcase(sel)\n\t\t\t\t\t4'h0 : out = a;\n\t\t\t\t\t4'h1 : out = b;\n\t\t\t\t\t4'h2 : out = c;\n\t\t\t\t\t4'h3 : out = d;\n\t\t\t\t\t4'h4 : out = e;\n\t\t\t\t\t4'h5 : out = f;\n\t\t\t\t\t4'h6 : out = g;\n\t\t\t\t\t4'h7 : out = h;\n\t\t\t\t\t4'h8 : out = i;\n\t\t\t\t\tdefault : out = 16'hFFFF;\n\t\t\t\tendcase\n\t\t\tend\n\n\t\tendmodule"
  },
  {
    "id": "10",
    "instruction": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.",
    "module_declaration": "module top_module( \n\t\t\tinput [1023:0] in,\n\t\t\tinput [7:0] sel,\n\t\t\toutput [3:0] out \n\t\t);",
    "output": "module top_module( \n\t\t\tinput [1023:0] in,\n\t\t\tinput [7:0] sel,\n\t\t\toutput [3:0] out \n\t\t);\n    \n\t\t\tassign out = in[sel*4 +: 4];\n\n\t\tendmodule"
  },
  {
    "id": "11",
    "instruction": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.",
    "module_declaration": "module top_module( \n\t\t\tinput [1023:0] in,\n\t\t\tinput [7:0] sel,\n\t\t\toutput [3:0] out \n\t\t);",
    "output": "module top_module (\n\t\t\tinput [1023:0] in,\n\t\t\tinput [7:0] sel,\n\t\t\toutput [3:0] out\n\t\t);\n\n\t\t\tassign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};\n\n\t\tendmodule"
  },
  {
    "id": "12",
    "instruction": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.",
    "module_declaration": "module top_module( \n\t\t\tinput a, b,\n\t\t\toutput cout, sum \n\t\t);",
    "output": "module top_module( \n\t\t\tinput a, b,\n\t\t\toutput cout, sum \n\t\t);\n  \n\t\t\tassign sum = a ^ b;\n\t\t\tassign cout = a & b;\n\n\t\tendmodule"
  },
  {
    "id": "13",
    "instruction": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.",
    "module_declaration": "module top_module( \n\t\t\tinput a, b, cin,\n\t\t\toutput cout, sum \n\t\t);",
    "output": "module top_module( \n\t\t\tinput a, b, cin,\n\t\t\toutput cout, sum \n\t\t);\n  \n\t\t\tassign sum = a ^ b ^ cin;\n\t\t\tassign cout = a & b | a & cin | b & cin;\n\n\t\tendmodule"
  },
  {
    "id": "14",
    "instruction": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.",
    "module_declaration": "module top_module (\n\t\t\tinput [7:0] a,\n\t\t\tinput [7:0] b,\n\t\t\toutput [7:0] s,\n\t\t\toutput overflow\n\t\t);",
    "output": "module top_module (\n\t\t\tinput [7:0] a,\n\t\t\tinput [7:0] b,\n\t\t\toutput [7:0] s,\n\t\t\toutput overflow\n\t\t);\n     \n\t\t\tassign s = a + b;\n\t\t\tassign overflow = (~(a[7] ^ b[7])) & (s[7] != a[7]);\n\n\t\tendmodule"
  },
  {
    "id": "15",
    "instruction": "Now that you know how to build a full adder, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see.",
    "module_declaration": "module top_module( \n\t\t\tinput [2:0] a, b,\n\t\t\tinput cin,\n\t\t\toutput [2:0] cout,\n\t\t\toutput [2:0] sum \n\t\t);",
    "output": "module top_module( \n\t\t\tinput [2:0] a, b,\n\t\t\tinput cin,\n\t\t\toutput [2:0] cout,\n\t\t\toutput [2:0] sum \n\t\t);\n\t\t\twire [2:0] cout1;\n\t\t\tfadd f1(a[0],b[0],cin,cout1[0],sum[0]);\n\t\t\tfadd f2(a[1],b[1],cout1[0],cout1[1],sum[1]);\n\t\t\tfadd f3(a[2],b[2],cout1[1],cout1[2],sum[2]);\n\t\t\tassign cout = cout1;\n\t\tendmodule\n\t\n\t\tmodule fadd( \n\t\t\tinput a, b, cin,\n\t\t\toutput cout, sum \n\t\t);\n\t\t\tassign sum = a^b^cin;\n\t\t\tassign cout = (a&b)|(b&cin)|(a&cin);\n\t\tendmodule"
  },
  {
    "id": "16",
    "instruction": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.",
    "module_declaration": "module top_module (\n\t\t\tinput a,\n\t\t\tinput b,\n\t\t\tinput c,\n\t\t\tinput d,\n\t\t\toutput out_sop,\n\t\t\toutput out_pos\n\t\t);",
    "output": "module top_module (\n\t\t\tinput a,\n\t\t\tinput b,\n\t\t\tinput c,\n\t\t\tinput d,\n\t\t\toutput out_sop,\n\t\t\toutput out_pos\n\t\t); \n  \n\t\t\tassign out_sop = (c & d) | (~a & ~b & c);\n\t\t\tassign out_pos = (c) & (~a | b) & (d | ~b);\n\n\t\tendmodule"
  },
  {
    "id": "17",
    "instruction": "Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.",
    "module_declaration": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput areset,   // active high asynchronous reset\n\t\t\tinput [7:0] d,\n\t\t\toutput [7:0] q\n\t\t);",
    "output": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput areset,\n\t\t\tinput [7:0] d,\n\t\t\toutput [7:0] q\n\t\t);\n\t\t\n\t\t\talways@(posedge clk,posedge areset)begin\n\t\t\t\tif(areset)\n\t\t\t\t\tq <= 0;\n\t\t\t\telse\n\t\t\t\t\tq <= d;\n\t\t\tend\n\n\t\tendmodule"
  },
  {
    "id": "18",
    "instruction": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.",
    "module_declaration": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput reset,      // Synchronous active-high reset\n\t\t\toutput [3:0] q\n\t\t);",
    "output": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput reset,\n\t\t\toutput [3:0] q\n\t\t);\n  \n\t\t\talways@(posedge clk)begin\n\t\t\t\tif(reset)\n\t\t\t\t\tq <= 0;\n\t\t\t\telse\n\t\t\t\t\tq <= q + 1'b1;\n\t\t\tend\n\n\t\tendmodule"
  },
  {
    "id": "19",
    "instruction": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.",
    "module_declaration": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput reset,        // Synchronous active-high reset\n\t\t\toutput [3:0] q\n\t\t);",
    "output": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput reset,       \n\t\t\toutput [3:0] q\n\t\t);\n  \n\t\t\talways@(posedge clk) begin\n\t\t\t\tif(reset | q==9)\n\t\t\t\t\tq <= 0;\n\t\t\t\telse\n\t\t\t\t\tq <= q + 1'b1;\n\t\t\tend\n\n\t\tendmodule"
  },
  {
    "id": "21",
    "instruction": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second). reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.",
    "module_declaration": "module top_module(\n\t\t\tinput clk,\n\t\t\tinput reset,\n\t\t\tinput ena,\n\t\t\toutput pm,\n\t\t\toutput [7:0] hh,\n\t\t\toutput [7:0] mm,\n\t\t\toutput [7:0] ss\n\t\t);",
    "output": "module top_module(\n\t\t\tinput clk,\n\t\t\tinput reset,\n\t\t\tinput ena,\n\t\t\toutput pm,\n\t\t\toutput [7:0] hh,\n\t\t\toutput [7:0] mm,\n\t\t\toutput [7:0] ss\n\t\t); \n\t\t\talways@(posedge clk)\n\t\t\t\tbegin\n\t\t\t\t\tif(reset) begin hh[3:0]<=4'd2;hh[7:4]<=4'd1; mm<=8'h00; ss<=8'h00; pm<=1'b0; end\n\t\t\t\t\telse if(ena)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif(ss[3:0] != 4'd9) ss[3:0]<=ss[3:0]+4'd1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tss[3:0]<=4'd0;\n\t\t\t\t\t\t\t\t\tss[7:4]<=ss[7:4]+4'd1;\n\t\t\t\t\t\t\t\t\tif(ss[7:4]== 4'd5) \n\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\t\tss[7:4]<=4'd0;\n\t\t\t\t\t\t\t\t\t\t\tmm[3:0]<=mm[3:0]+4'd1;\n\t\t\t\t\t\t\t\t\t\t\tif(mm[3:0] == 4'd9)\n\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\tmm[3:0]<=4'd0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tmm[7:4]<=mm[7:4]+4'd1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(mm[7:4] == 4'd5)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmm[7:4]<=4'd0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thh[3:0]<=hh[3:0]+4'd1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hh[3:0] == 4'd9)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thh[3:0]<=4'd0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thh[7:4]<=hh[7:4]+4'd1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hh[3:0] == 4'd1 && hh[7:4]==4'd1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpm<=~pm;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thh[3:0]<=4'd2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thh[7:4]<=4'd1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hh[3:0] == 4'd2 && hh[7:4]==4'd1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thh[3:0]<=4'd1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thh[7:4]<=4'd0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\tend\n\t\tendmodule"
  },
  {
    "id": "22",
    "instruction": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second). reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.",
    "module_declaration": "module top_module(\n\t\t\tinput clk,\n\t\t\tinput reset,\n\t\t\tinput ena,\n\t\t\toutput pm,\n\t\t\toutput [7:0] hh,\n\t\t\toutput [7:0] mm,\n\t\t\toutput [7:0] ss\n\t\t);",
    "output": "module top_module(\n\t\t\tinput clk,\n\t\t\tinput reset,\n\t\t\tinput ena,\n\t\t\toutput pm,\n\t\t\toutput [7:0] hh,\n\t\t\toutput [7:0] mm,\n\t\t\toutput [7:0] ss\n\t\t); \n    \n\t\t\talways@(posedge clk) begin\n\t\t\t\tif (reset) begin\n\t\t\t\t\thh <= 8'h12;\n\t\t\t\t\tmm <= 0;\n\t\t\t\t\tss <= 0;\n\t\t\t\t\tpm <= 0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tif (ena) begin\n\t\t\t\t\t\tpm <= (hh == 8'h11 && mm == 8'h59 && ss == 8'h59)? ~pm : pm;\n\t\t\t\t\t\tif (ss == 8'h59) begin // ss = 59\n\t\t\t\t\t\t\tss <= 0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (mm == 8'h59) begin // mm = 59\n\t\t\t\t\t\t\t\tmm <= 0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (hh == 8'h12) begin\n\t\t\t\t\t\t\t\t\thh <= 8'h01;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\t\tif (hh[3:0] == 4'd9) begin\n\t\t\t\t\t\t\t\t\t\thh[3:0] <= 0;\n\t\t\t\t\t\t\t\t\t\thh[7:4] <= hh[7:4] + 4'd1;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\t\thh[3:0] <= hh[3:0] + 4'd1;  \n\t\t\t\t\t\t\t\tend\n\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\tif (mm[3:0] == 4'd9) begin\n\t\t\t\t\t\t\t\t\tmm[3:0] <= 0;\n\t\t\t\t\t\t\t\t\tmm[7:4] <= mm[7:4] + 4'd1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\tmm[3:0] <= mm[3:0] + 4'd1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tif (ss[3:0] == 4'd9) begin\n\t\t\t\t\t\t\t\tss[3:0] <= 0;\n\t\t\t\t\t\t\t\tss[7:4] <= ss[7:4] + 4'd1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tss[3:0] <= ss[3:0] + 4'd1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend   \n\t\t\t\tend\n\t\t\tend\n\t\t\n\t\tendmodule"
  },
  {
    "id": "26",
    "instruction": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n\n\t\t- State: A, Next state if in = 0: A, Next state if in = 1: B, Output: 0\n\t\t- State: B, Next state if in = 0: C, Next state if in = 1: B, Output: 0\n\t\t- State: C, Next state if in = 0: A, Next state if in = 1: D, Output: 0\n\t\t- State: D, Next state if in = 0: C, Next state if in = 1: B, Output: 1",
    "module_declaration": "module top_module(\n\t\t\tinput in,\n\t\t\tinput [1:0] state,\n\t\t\toutput [1:0] next_state,\n\t\t\toutput out\n\t\t);",
    "output": "module top_module(\n\t\t\tinput in,\n\t\t\tinput [1:0] state,\n\t\t\toutput [1:0] next_state,\n\t\t\toutput out\n\t\t\t); \n\n\t\t\tparameter A=2'd0, B=2'd1, C=2'd2, D=2'd3;\n\t\t\t\n\t\t\talways@(*)\n\t\t\t\tbegin\n\t\t\t\t\tcase(state)\n\t\t\t\t\t\tA: next_state <=in?B:A;\n\t\t\t\t\t\tB: next_state <=in?B:C;\n\t\t\t\t\t\tC: next_state <=in?D:A;\n\t\t\t\t\t\tD: next_state <=in?B:C;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\t\t\n\t\t\tassign out = (state == D);\n\t\tendmodule"
  },
  {
    "id": "27",
    "instruction": "Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.\n\t\t- State: 000, Next state if input x=0: 000, Next state if input x=1: 001, Output z: 0\n\t\t- State: 001, Next state if input x=0: 001, Next state if input x=1: 100, Output z: 0\n\t\t- State: 010, Next state if input x=0: 010, Next state if input x=1: 001, Output z: 0\n\t\t- State: 011, Next state if input x=0: 001, Next state if input x=1: 010, Output z: 1\n\t\t- State: 100, Next state if input x=0: 011, Next state if input x=1: 100, Output z: 1",
    "module_declaration": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput reset,   // Synchronous reset\n\t\t\tinput x,\n\t\t\toutput z\n\t\t);",
    "output": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput reset,   // Synchronous reset\n\t\t\tinput x,\n\t\t\toutput z\n\t\t);\n\t\t\n\t\t\tparameter a = 0, b = 1, c = 2, d = 3, e = 4;\n\t\t\treg [2:0] state, next_state;\n\t\t\n\t\t\talways @(*) begin\n\t\t\t\tcase (state)\n\t\t\t\t\ta: next_state = x ? b : a;\n\t\t\t\t\tb: next_state = x ? e : b;\n\t\t\t\t\tc: next_state = x ? b : c;\n\t\t\t\t\td: next_state = x ? c : b;\n\t\t\t\t\te: next_state = x ? e : d;\n\t\t\t\tendcase\n\t\t\tend\n\t\t\n\t\t\talways @(posedge clk) begin\n\t\t\t\tif (reset) begin\n\t\t\t\t\tstate <= a;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate <= next_state;\n\t\t\t\tend\n\t\t\tend\n\t\t\n\t\t\tassign z = (state == d || state == e);\n\t\t\n\t\tendmodule"
  },
  {
    "id": "28",
    "instruction": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).",
    "module_declaration": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput resetn,    // active-low synchronous reset\n\t\t\tinput x,\n\t\t\tinput y,\n\t\t\toutput f,\n\t\t\toutput g\n\t\t);",
    "output": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput resetn,    // active-low synchronous reset\n\t\t\tinput x,\n\t\t\tinput y,\n\t\t\toutput reg f,\n\t\t\toutput reg g\n\t\t); \n\t\t\n\t\t\tparameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;\n\t\t\treg [3:0] state, next_state;\n\t\t\t\n\t\t\talways@(*) begin\n\t\t\t\tcase(state)\n\t\t\t\t\tA: begin\n\t\t\t\t\t\tif(resetn) \n\t\t\t\t\t\t\tnext_state = f1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = A;\n\t\t\t\t\tend\n\t\t\t\t\tf1:     next_state = tmp0;\n\t\t\t\t\ttmp0: begin\n\t\t\t\t\t\tif(x)\n\t\t\t\t\t\t\tnext_state = tmp1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = tmp0;\n\t\t\t\t\tend\n\t\t\t\t\ttmp1: begin\n\t\t\t\t\t\tif(~x)\n\t\t\t\t\t\t\tnext_state = tmp2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = tmp1;\n\t\t\t\t\tend\n\t\t\t\t\ttmp2: begin\n\t\t\t\t\t\tif(x)\n\t\t\t\t\t\t\tnext_state = g1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = tmp0;\n\t\t\t\t\tend\n\t\t\t\t\tg1: begin\n\t\t\t\t\t\tif(y)\n\t\t\t\t\t\t\tnext_state = g1p;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = tmp3;\n\t\t\t\t\tend\n\t\t\t\t\ttmp3: begin\n\t\t\t\t\t\tif(y)\n\t\t\t\t\t\t\tnext_state = g1p;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = g0p;\n\t\t\t\t\tend\n\t\t\t\t\tg1p: begin\n\t\t\t\t\t\tif(~resetn)\n\t\t\t\t\t\t\tnext_state = A;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = g1p;\n\t\t\t\t\tend\n\t\t\t\t\tg0p: begin\n\t\t\t\t\t\tif(~resetn)\n\t\t\t\t\t\t\tnext_state = A;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = g0p;\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\t\t\n\t\t\talways@(posedge clk) begin\n\t\t\t\tif(~resetn)\n\t\t\t\t\tstate <= A;\n\t\t\t\telse\n\t\t\t\t\tstate <= next_state;\n\t\t\tend\n\t\t\t\n\t\t\talways@(posedge clk) begin\n\t\t\t\tcase(next_state)\n\t\t\t\t\tf1:     f <= 1'b1;\n\t\t\t\t\tg1:\t\tg <= 1'b1;\n\t\t\t\t\ttmp3:\tg <= 1'b1;\n\t\t\t\t\tg1p:    g <= 1'b1;\n\t\t\t\t\tg0p:    g <= 1'b0;\n\t\t\t\t\tdefault: begin\n\t\t\t\t\t\t\tf <= 1'b0;\n\t\t\t\t\t\t\tg <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\t\n\t\tendmodule"
  },
  {
    "id": "29",
    "instruction": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.",
    "module_declaration": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput reset,\n\t\t\toutput [9:0] q\n\t\t);",
    "output": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput reset,\n\t\t\toutput [9:0] q\n\t\t);\n    \n\t\t\talways @(posedge clk) begin\n\t\t\t\tif (reset) q <= 0;\n\t\t\t\telse begin\n\t\t\t\tif (q < 999) q <= q + 1'b1;\n\t\t\t\t\telse q <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\n\t\tendmodule"
  },
  {
    "id": "30",
    "instruction": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).",
    "module_declaration": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput shift_ena,\n\t\t\tinput count_ena,\n\t\t\tinput data,\n\t\t\toutput [3:0] q\n\t\t);",
    "output": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput shift_ena,\n\t\t\tinput count_ena,\n\t\t\tinput data,\n\t\t\toutput [3:0] q\n\t\t);\n\t\t\n\t\t\treg [3:0] shift_temp;\n\t\t\n\t\t\talways @(posedge clk) begin\n\t\t\t\tif (shift_ena) begin\n\t\t\t\t\tshift_temp <= {shift_temp[2:0], data};\n\t\t\t\tend\n\t\t\t\telse if (count_ena) begin\n\t\t\t\t\tshift_temp <= shift_temp - 1'b1;\n\t\t\t\tend \n\t\t\tend\n\t\t\n\t\t\tassign q = shift_temp;\n\t\t\t\n\t\tendmodule"
  },
  {
    "id": "31",
    "instruction": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).",
    "module_declaration": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput shift_ena,\n\t\t\tinput count_ena,\n\t\t\tinput data,\n\t\t\toutput [3:0] q\n\t\t);",
    "output": "module top_module (\n\t\t\tinput clk,\n\t\t\tinput shift_ena,\n\t\t\tinput count_ena,\n\t\t\tinput data,\n\t\t\toutput [3:0] q\n\t\t);\n\t\t\t\n\t\t\talways@(posedge clk)begin\n\t\t\t\tif(shift_ena)begin\n\t\t\t\t\tq <= {q[2:0], data};\n\t\t\t\tend\n\t\t\t\telse if(count_ena)begin\n\t\t\t\t\tq <= q - 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\n\t\tendmodule"
  }
]